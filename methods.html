<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>JavaCall.jl -- Call Java from Julia</title>

    <link rel="stylesheet" href="res/styles.css">
    <link rel="stylesheet" href="res/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <style TYPE="text/css">
      code.has-jax {font: inherit; font-size: 100%; background: inherit; border: inherit;}
    </style>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [['$','$'], ['\\(','\\)']],
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'header'] // removed 'code' entry
          }
      });
      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i = 0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });
    </script>  
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>JavaCall.jl</h1>
        <p>Call Java Programs from Julia </p>

        <ul>
          <li><a href="https://github.com/aviks/JavaCall.jl/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/aviks/JavaCall.jl/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/aviks/JavaCall.jl">View On <strong>GitHub</strong></a></li>
        </ul>
        <div class="menu">
        <ul>
           <li><a href="index.html">Home</a></li>
           <li><a href="types.html">Types</a></li>
           <li><a href="methods.html">Methods</a></li>
           <li><a href="gc.html">GC</a></li>
	   <li><a href="reflection.html">Reflection API</a></li>
	   <li><a href="iterators.html">Iterators</a></li>
           <li><a href="faq.html">Troubleshooting and FAQs</a></li>
        </ul>
      </div>
      </header>
      <section>
	<h1 id="lifecycle-and-api">Lifecycle and API</h1>

<h2 id="loading">Loading</h2>

<p>When the module is first loaded, via <code class="highlighter-rouge">using</code> or <code class="highlighter-rouge">load</code>, it searches for the JVM dynamic library, <code class="highlighter-rouge">libjvm.so|libjvm.dylib|jvm.dll</code>. The search is dependent on the <code class="highlighter-rouge">JAVA_HOME</code> environment variable, which must be set, except on OSX, where the <code class="highlighter-rouge">/usr/libexec/java_home</code> command is used to infer it. In case the library is not found, the module load fails, and no further functionality is available.</p>

<p>If the JVM library is now found even when it legitimately exists, a workaround is to set the <code class="highlighter-rouge">JAVA_LIB</code> environment variable to the path to library file. However, a better option will be a pull request updating the library search code.</p>

<p>Currently, as a debugging aid, the module will print the location of the jvm library when it loads.</p>

<h2 id="initialisation">Initialisation</h2>

<p>The <code class="highlighter-rouge">JavaCall.init(args::Array{String, 1})</code> method must to used to load and initialise the Java Virtual Machine before any other functions in this module can be called. The <code class="highlighter-rouge">args</code> parameter is an array containing JVM initialisation arguments. This can be used to set, for example, the system classpath, and the maximum Java heap. Any valid commandline argument to the <code class="highlighter-rouge">java</code> command can be used. Unrecognised arguments are silently discarded.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">JavaCall</span><span class="o">.</span><span class="n">init</span><span class="x">([</span><span class="s">"-Xmx512M"</span><span class="x">,</span> <span class="s">"-Djava.class.path=</span><span class="si">$</span><span class="s">(@__DIR__)"</span><span class="x">,</span> <span class="s">"-verbose:jni"</span><span class="x">,</span> <span class="s">"-verbose:gc"</span><span class="x">])</span>
</code></pre></div></div>

<p>Note that only one JVM can be initialised within a process. Hence, the <code class="highlighter-rouge">init</code> function can be called only once per process.</p>

<h2 id="referencing-types">Referencing types</h2>

<p>As described in the [types][types.html] section, the @jimport macro returns the Julia type that corresponds to the relevant Java class. This Julia type can the be used a proxy for the Java type, and can be used for instantiating objects of that class, or calling static methods on it.</p>
<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jlm</span> <span class="o">=</span> <span class="nd">@jimport</span> <span class="s">"java.lang.Math"</span>
<span class="n">jnu</span> <span class="o">=</span> <span class="nd">@jimport</span> <span class="n">java</span><span class="o">.</span><span class="n">net</span><span class="o">.</span><span class="n">URL</span>
</code></pre></div></div>
<p>The syntax for importing inner classes is slightly different.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">myPackage</span><span class="o">;</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Outer</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Inner</span><span class="o">{</span>
      <span class="kd">public</span> <span class="kt">void</span> <span class="nf">innerMethod</span><span class="o">()</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"In Inner class Method"</span><span class="o">);</span>
      <span class="o">}</span>
    <span class="o">}</span><span class="n">l</span>
	<span class="kd">public</span> <span class="nc">Inner</span> <span class="nf">createrInnerObject</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">Inner</span> <span class="n">innerObj</span><span class="o">=</span><span class="k">new</span> <span class="nc">Inner</span><span class="o">();</span>
      <span class="k">return</span> <span class="n">innerObj</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>To import the outer and inner clasess, one would use <code class="highlighter-rouge">Outer$Inner</code> instead of <code class="highlighter-rouge">Outer.Inner</code>.</p>
<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jouter</span><span class="o">=</span><span class="nd">@jimport</span> <span class="n">myPackage</span><span class="o">.</span><span class="n">Outer</span>
<span class="n">jinner</span><span class="o">=</span><span class="nd">@jimport</span> <span class="n">myPackage</span><span class="o">.</span><span class="n">Outer</span><span class="o">$</span><span class="n">Inner</span>
</code></pre></div></div>
<h2 id="calling-static-methods">Calling Static Methods</h2>

<p>The primary interface to Java methods is the <code class="highlighter-rouge">jcall</code> function. Like the inbuilt Julia <code class="highlighter-rouge">ccall</code> function, you need to supply the return type, a tuple of the argument types, and the method arguments themselves. The first argument to jcall however is the receiver of the method in Java. In case of static methods therefore, the receiver is the Julia type corresponding to the Java class that holds the method.</p>

<p>Arguments are converted if possible to the specified types, via the usual Julia <code class="highlighter-rouge">convert</code> function. This includes converting <code class="highlighter-rouge">JavaObject</code> instances referencing a particular java class, to a <code class="highlighter-rouge">JavaObject</code> referencing its superclass. This allows some measure of the polymorphism inherent in Java methods. Strings are automatically converted, and hence Julia strings may be passed directly into <code class="highlighter-rouge">jcall</code>.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jcall</span><span class="x">(</span><span class="n">jlm</span><span class="x">,</span> <span class="s">"sin"</span><span class="x">,</span> <span class="n">jdouble</span><span class="x">,</span> <span class="x">(</span><span class="n">jdouble</span><span class="x">,),</span> <span class="nb">pi</span><span class="o">/</span><span class="mi">2</span><span class="x">)</span> <span class="c">#1.0</span>
</code></pre></div></div>

<h2 id="initialising-objects-via-constructors">Initialising Objects via Constructors</h2>
<p>Each of the Julia <code class="highlighter-rouge">JavaObject</code> types contain a constructor that looks much like the <code class="highlighter-rouge">jcall</code> function. You provide a tuple of argument types, and the arguments themselves, and it return an instance of <code class="highlighter-rouge">JavaObject</code> that wraps a Java object of the corresponding class. Unlike <code class="highlighter-rouge">jcall</code> however, in this case the receiver and the return type is implicit, and does not need to specified.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gurl</span> <span class="o">=</span> <span class="n">jnu</span><span class="x">((</span><span class="n">JString</span><span class="x">,),</span> <span class="s">"http://www.google.com"</span><span class="x">)</span>
<span class="n">outerObj</span><span class="o">=</span> <span class="n">jouter</span><span class="x">((),)</span>
</code></pre></div></div>

<h2 id="calling-instance-methods">Calling Instance Methods</h2>

<p>Calling instance methods uses the <code class="highlighter-rouge">jcall</code> function, with an instance of the <code class="highlighter-rouge">JavaObject</code> type as the receiver. As before, the method takes as arguments the return type, the tuple of the argument types, and the arguments themselves.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">jcall</span><span class="x">(</span><span class="n">gurl</span><span class="x">,</span> <span class="s">"getHost"</span><span class="x">,</span> <span class="n">JString</span><span class="x">,())</span> <span class="c">#"wwww.google.com"</span>
<span class="n">innerObj</span><span class="o">=</span><span class="n">jcall</span><span class="x">(</span><span class="n">outerObj</span><span class="x">,</span> <span class="s">"createrInnerObject"</span><span class="x">,</span> <span class="n">jinner</span><span class="x">,())</span>
<span class="n">jcall</span><span class="x">(</span><span class="n">innerObj</span><span class="x">,</span> <span class="s">"innerMethod"</span><span class="x">,</span> <span class="kt">Nothing</span><span class="x">,())</span> <span class="c">#Prints "In Inner class Method"</span>
</code></pre></div></div>

<h2 id="calling-array-methods">Calling Array Methods</h2>

<p>Java arrays are referenced as Julia <code class="highlighter-rouge">Arrays</code> of the relevant (aliased) Java types. Hence a Java <code class="highlighter-rouge">int[]</code> is <code class="highlighter-rouge">Array{jint, 1}</code> in Julia. And similar for all other primitive types. All arrays of non-primitive Java objects are <code class="highlighter-rouge">Array{JavaObject{T}, 1}</code> in Julia, where <code class="highlighter-rouge">T</code> is the name of the relevant Java class.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">j_u_arrays</span> <span class="o">=</span> <span class="nd">@jimport</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">Arrays</span>
<span class="n">jcall</span><span class="x">(</span><span class="n">j_u_arrays</span><span class="x">,</span> <span class="s">"binarySearch"</span><span class="x">,</span> <span class="n">jint</span><span class="x">,</span> <span class="x">(</span><span class="kt">Array</span><span class="x">{</span><span class="n">jint</span><span class="x">,</span><span class="mi">1</span><span class="x">},</span> <span class="n">jint</span><span class="x">),</span> <span class="x">[</span><span class="mi">10</span><span class="x">,</span><span class="mi">20</span><span class="x">,</span><span class="mi">30</span><span class="x">,</span><span class="mi">40</span><span class="x">,</span><span class="mi">50</span><span class="x">,</span><span class="mi">60</span><span class="x">],</span> <span class="mi">40</span><span class="x">)</span>
<span class="n">jcall</span><span class="x">(</span><span class="n">j_u_arrays</span><span class="x">,</span> <span class="s">"binarySearch"</span><span class="x">,</span> <span class="n">jint</span><span class="x">,</span> <span class="x">(</span><span class="kt">Array</span><span class="x">{</span><span class="n">JavaObject</span><span class="x">,</span><span class="mi">1</span><span class="x">},</span> <span class="n">JavaObject</span><span class="x">),</span> <span class="x">[</span><span class="s">"123"</span><span class="x">,</span><span class="s">"abc"</span><span class="x">,</span><span class="s">"uvw"</span><span class="x">,</span><span class="s">"xyz"</span><span class="x">],</span> <span class="s">"uvw"</span><span class="x">)</span>
<span class="n">jcall</span><span class="x">(</span><span class="n">j_u_arrays</span><span class="x">,</span> <span class="s">"copyOf"</span><span class="x">,</span> <span class="kt">Array</span><span class="x">{</span><span class="n">jint</span><span class="x">,</span> <span class="mi">1</span><span class="x">},</span> <span class="x">(</span><span class="kt">Array</span><span class="x">{</span><span class="n">jint</span><span class="x">,</span> <span class="mi">1</span><span class="x">},</span> <span class="n">jint</span><span class="x">),</span> <span class="x">[</span><span class="mi">1</span><span class="x">,</span><span class="mi">2</span><span class="x">,</span><span class="mi">3</span><span class="x">],</span> <span class="mi">3</span><span class="x">)</span>
<span class="n">jcall</span><span class="x">(</span><span class="n">j_u_arrays</span><span class="x">,</span> <span class="s">"copyOf"</span><span class="x">,</span> <span class="kt">Array</span><span class="x">{</span><span class="n">JObject</span><span class="x">,</span> <span class="mi">1</span><span class="x">},</span> <span class="x">(</span><span class="kt">Array</span><span class="x">{</span><span class="n">JavaObject</span><span class="x">,</span> <span class="mi">1</span><span class="x">},</span> <span class="n">jint</span><span class="x">),</span> <span class="x">[</span><span class="s">"a"</span><span class="x">,</span><span class="s">"b"</span><span class="x">,</span><span class="s">"c"</span><span class="x">],</span> <span class="mi">3</span><span class="x">)</span>
</code></pre></div></div>

<p>As noted in the introduction, only one dimensional arrays are currently supported.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">s</span><span class="o">=</span><span class="n">JString</span><span class="x">(</span><span class="s">"Hello World"</span><span class="x">)</span>
</code></pre></div></div>

<p>When a Java string is returned from a method call, it can be converted to a Julia string using the <code class="highlighter-rouge">bytestring(s::JString)</code> function.</p>

<h2 id="unload">Unload</h2>

<p>The <code class="highlighter-rouge">JavaCall.destroy</code> command will unload the JVM, destryoing all its references. Note however that even after calling destroy, a new JVM cannot be initialised in the same process. Initialising a JVM is a effectively a one way process.</p>

      </section>
      <footer>
        <p></p>
        <p><small>This project is maintained by <a href="http://www.sengupta.net/musings/">Avik Sengupta</a>. <br /> Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="res/scale.fix.js"></script>
    <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-37085988-1");
            pageTracker._trackPageview();
            } catch(err) {}
    </script>
  </body>
</html>
